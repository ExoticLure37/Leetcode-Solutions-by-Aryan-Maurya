struct UnionFind {
	int n;
	vector<int> rank;
	vector<int> parent;
    
	// store other info as required
	UnionFind(int n) {
		rank.resize(n);
		fill(rank.begin(), rank.end(), 1);
		parent.resize(n);
		for (int i = 0; i < n; i++) {
			parent[i] = i;
		}
	}

	int get(int a) {
		return parent[a] = (parent[a] == a ? a : get(parent[a]));
	}
	void merge(int a, int b) {
		a = get(a);
		b = get(b);
		if (a == b) {
			return;
		}
		
		if (rank[a] > rank[b]) {
			parent[b] = a;
            rank[a]+=rank[b];
		} else {
			parent[a] = b;
            rank[b]+=rank[a];
		}
	}
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n=graph.size();
        int m=graph[0].size();

        if(initial.size()==0)return initial[0];

        sort(initial.begin(),initial.end());

        vector<set<pair<int,int>>> con(n);
        
        UnionFind dsu(n);
        
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(i==j)continue;
                if(graph[i][j]==1){
                    dsu.merge(i,j);
                }
            }
        }
        
        int ans=INT_MAX;
        for(int i=0;i<initial.size();i++){
            int temp=initial[i];
            int par=dsu.get(temp);
            con[par].insert({temp,dsu.rank[par]});
        }
        
        int comp=INT_MIN;
        for(int i=0;i<n;i++){
            if(con[i].size()==1){
                for(auto j:con[i]){
                    if(j.second>comp){
                        comp=j.second;
                        ans=j.first;
                    }
                    else if(j.second==comp){
                        ans=min(ans,j.first);
                    }
                }
            }
        }

        if(ans==INT_MAX)return initial[0];
        return ans;


    }
};